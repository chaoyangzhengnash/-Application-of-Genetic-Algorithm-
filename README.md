# Application of Genetic Algorithm on a practical case of BIXI Montreal
This is a group project made by Chaoyang zheng, Hoa Nguyen, Xinyue Tan and Zhenghao Wang for master course:Algorithms for Optimization and Big Data Analysis in HEC MONTREAL.

## 1.	Introduction 
Bixi bike Montreal is a public sharing system that allows citizens to rent bikes on hourly, daily or monthly basis at a small fee. Bixi Montreal was created in 2014 and by 2018, it owns 552 docking stations and approximately 7,000 vehicles. The majority of the Bixi’s docking stations locates in the downtown area, the Plateau-Mont-Royal area, and near universities. The number of bikes at each station depends on the demand for biking service in the neighborhood where that station locates. When a customer rent a bike from a docking station, he removes a bike from the station, goes on his trip and returns the bike to any of the stations he finds in 30 minutes. Because a bike can be returned to any of the docking station, there often cases that some of the docking stations are empty after some time while the others are full. Thus, Bixi needs redistribute the bikes each day using large trucks. 

For this project, we aim at applying the Genetic Algorithm (GA) for Travel Salesman Problem (TSP) on the Bixi docking stations problem. The goal is to find the shortest path to visit all the chosen docking stations (just one time at each station) by solving an open loop TSP. 

The reminder of the paper is organized as follows: Section 2 will describe the classic TSP and the methodology we will apply. Section 3 we will discuss about the structure of the data we used. Section 4 is to explain how we implement Genetic Algorithm. Section 5 we will present the result of our algorithm and a comparison of the result of our algorithm and the Variable Neighborhood Search’s (VNS). Section 6 is to show the challenges and difficulties we met and takeaways.  Section 7 will be our conclusion. 

## 2.	Literature review and Methodology 
### 2.1.	TSP
TSP is a well-known problem for finding the optimal path which can be solved by various methods. Many algorithms have been developed for TSP but here we are using the concept of genetic algorithm. Other approximation techniques for finding near optimum solutions for TSP based on heuristics are proposed in the literature such as [1] simulated annealing [2], ant colonies [3], genetic algorithms (GA) [4] and [5]. John Holland's pioneering book "Adaptation in natural Artificial System (1975, 1992) showed how the evolutionary process can be applied to solve a wide variety of problems using a highly parallel technique that is now called genetic algorithm. Genetic Algorithms have been applied to a large number of real-world problems. The proposed genetic algorithm in this paper build on much work done by previous researchers [4]. Here we introduce the detailed implementation to solve a practical issue.
### 2.2.	Metaheuristics 
Meta-heuristics can be defined as search algorithms, which were initially designed to find satisfying approximated optimal solutions in a reasonable computation time for several optimization problems. In contrast to conventional algorithms [6]. Metaheuristics do not iteratively visit each element in the search space. They actually guide the search process towards regions that may contain high quality solutions. Meta-heuristics can be classified under two main categories [7]: single solution and population-based search. The former proceeds with one initial solution and try to enhance its quality by repeatedly moving to a better solution. Examples of such type of algorithms are simulated annealing (SA) [8] and tabu search (TS) [9]. However, population-based are meta-heuristics in which a population of solutions is maintained at each iteration. Evolutionary algorithms [10] are good examples for population-based algorithms. 
#### 2.2.1.	Genetic Algorithms (GAs)
Genetic Algorithms (GAs) are known as adaptive heuristic search algorithms. GAs are inspired by biological evolution and they are based on the idea of the survival of the fittest. The power of GAs lies in their ability to avoid randomness search by intelligently exploit historical information to direct the search process towards the regions of better performance within the solution space. GAs ultimately converges to the individual which is the best adapted to the environment and thus obtaining the optimal or a satisfactory solution. After generating a set of initial solutions, GAs evolve through three main genetic operations: Selection, Crossover, and Mutation. 

- Selection: In this phase, the algorithm decides which individual (solution) will survive or pass its genes to the next generation. Better solutions have always more chances to survive. The selection operation is therefore to prevent the loss of effective gene to make high performance individuals survival with greater probability, thereby enhancing the global convergence and computational efficiency.

- Crossover: The crossover operation is used to assemble a new individual and do effective search in the solution space. There are several techniques to accomplish the crossover such as single point, multiple points, and variable point crossovers. The efficiency of those latters depends mostly on the problem. 

- Mutation: This operator is usually used to maintain diversity and to prevent premature convergence. It is often performed with low probability since it results in a random walk through the search space. 


#### 2.2.2.	Variable neighborhood search (VNS)  
VNS is a single solution meta-heuristic that is firstly proposed by Hansen and Meladenovic in 1997. The principle of VNS is to extend a local search routine in order to get out of local optima, by systematically drawing solutions at random within a set of neighborhoods increasingly far from the current best solution, performing descents from there with the local search routine and recentering the search around a better solution if one is found. [11]

VNS has been proved to be very useful for obtaining high quality approximate solutions to wide range of optimization problems. The high performance of VNS is stemmed from its ability to explore distant neighborhoods of the current incumbent solution [10]. VNS can move from a solution to another by repeatedly applying local search improvements to reach local optima. Once a local optimum is detected, VNS is able to jump out of it and eventually find better solutions by dynamically changing the neighborhood‘s structures. Therefore, VNS is more likely to prevent the optimization process from rapidly falling into local optima.

VNS has several advantageous in comparison with conventional metaheuristics such as tabu search, simulated annealing. The algorithm is not only easy to achieve since its structure is simple, but it is also irrelevant to the problem and is suitable for all kinds of optimization problems. Several extensions have been derived from VNS such as Variable Neighborhood Descent (VND), Reduced VNS (RVNS) [10], skewed VNS (SVNS) [12], etc... These variants have been invented in order to enhance the performance of the basic VNS scheme as well as to adapt it for different optimization scenarios.

## 3.	Data structure and conditions
### 3.1.	Data structure
The major input data we used for this project is the historical record of Bixi’s bikes movement in 2018. The data was obtained from an open source called Kaggle. The structure of the raw data includes: index, code, start_latitude, start_longtitude, count of lent trips, and count of return trips. One column was added as net_flow which determines that activeness of the stations. 
-	Index: counts the number of rows in the raw data. The count starts with 0. 
-	Code: contains the identification number of the docking station. Each code is a unique number.
-	Start_latitude and start_longtitude: the coordinates of the stations in a two-dimensional graph. The coordinates of the stations are unique. 
-	Count of lent trips: counts the number of bikes rented from each station for the operated year 2019. 
-	Count of return trips: counts the number of bikes returned to each station for the operated year 2019.
-	Net_flow: calculates the absolute value of the difference between the Count of lent trips and the Count of return trips.
